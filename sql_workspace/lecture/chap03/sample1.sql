-- sample1.sql

-- ------------------------------------------------------
--
-- ------------------------------------------------------
-- 단일(행) (반환)함수의 구분:

-- (1) 문자 (처리)함수 : INITCAP
-- ------------------------------------------------------
--  첫글자만 대문자로 변경
-- ------------------------------------------------------
SELECT 'ORACLE SQL', initcap('ORACLE SQL')
FROM dual;

SELECT email, initacp(email)
FROM employees;
-- ------------------------------------------------------
-- (2) 문자 (처리)함수 : UPPER
-- ------------------------------------------------------
--  모든 글자를 대문자로 변경
-- ------------------------------------------------------
SELECT 'Oracle Sql', upper('Oracle Sql')
FROM dual;

SELECT last_name, upper(last_name)
FROM employees;

SELECT last_name, salary
FROM employees
-- WHERE upper(last_name) = 'KING';     -- *Decommendation*: the indexes ~~~~
                                        -- 이렇게 이름 앞에 함수 입력하면 인덱스 입력 불가.
WHERE last_name = initcap('KING');     
        -- *REcommendation*: the indexes with the column can be~~

-- ------------------------------------------------------
-- (3) 문자 (처리)함수 : LOWER
-- ------------------------------------------------------ 
--      모든 글자를 소문자로 변경
-- ------------------------------------------------------
SELECT 'Oracle Sql', lower('Oracle Sql')
FROM dual;

SELECT last_name, lower(last_name)
FROM employees;
-- ------------------------------------------------------
-- (4) 문자 (처리)함수 : CONCAT
-- ------------------------------------------------------ 
--      두 문자열 연결(Concatenation)
-- ------------------------------------------------------
SELECT 'Oracle'||'Sql'||'third', 
        concat(concat('Oracle', 'Sql'), 'third') --> # concat은 이렇게 3개 쓰려면 이런식으로 중첩해가면서 써야해서 파이프라인 씀.
FROM dual;  -- || : Concatenation Operator ==> concat function

SELECT last_name||salary, concat(last_name,salary) --> 테이블에 쓰냐, 컬럼에 쓰냐 이런 차이 .
FROM employees;                                       --> 이건 문자열과 숫자열 붙인거. 숫자열은 문자열로 변환됨

SELECT last_name||hire_date, concat(last_name, hire_date)
From employees;                                                 --> 이건 문자열과 날짜 타입이 결합된거. 날짜형 형식이 문자열로 변환됨.

-- ------------------------------------------------------
-- (3) 문자 (처리)함수 : LENGTH
-- ------------------------------------------------------ 
--      문자열의 길이 반환
-- ------------------------------------------------------
-- ~~ 여기 많아서 안씀.
-- A. LENGTH reuturn~~~ 이거랑 LENGTHB 는 알아두자 ! 바이트랑 문자의 갯수 반환하는거 !!!!!!!!!!!!!!!!!
-- B.
-- C.
-- D. 
-- E. 
-- ------------------------------------------------------
SELECT 'Oracle', length('Oracle')
FROM dual;

SELECT last_name, length(last_name)
FROM employees;

SELECT
        unistr('X'), -- 문자 X에 대해 unistr이라는 함수를 적용. 유니코드로 만드는 과정.
        lengthb(unistr('X')) lengthb, -- 유니코드로 만든 문자의 길이를 보면 bytes로 보면 2바이트 소요. 같은 문자열인데, 어느 문자집합을 따르느냐에
                                        -- 따라서 차지하는 바이트가 다르다..!는 의미래...
        lengthc(unistr('X')) lengthc,  -- 문자의 갯수를 표현하라 하면 갯수는 1
        length('X') lengthXC    
        length('X') lengthB
FROM
        dual;

SELECT
        '한글',
        length('한글') AS length, -- 다국어 문자는 그냥 문자 갯수대로 나옴. 2로.
        lengthb('한글') AS lengthb, -- 하지만, 바이트로 하면 한 문자당 3바이트라 6바이트 뜸.
        lengthc('한글') As lengthc -- 
        -- length2('한글') AS length2,
        -- length4('한글') As length4
FROM
        employees;

-- ------------------------------------------------------
-- (6) 문자 (처리)함수 : INSTR
-- ------------------------------------------------------ 
--      문자열에서, 특정 문자열의 위치(인덱스) 반환
-- ------------------------------------------------------
-- 주의) Oracle 의 인덱스 번호는 1부터 시작함!!!!!
-- ------------------------------------------------------
SELECT 
        instr('MILLER', 'L', 1, 2), -- 1: offset, 2: occurence
                                    -- 첫번째 매개변수 1은 offset라 부름. L을 찾을때 처음부터 찾을까요, 중간부터 찾을까요 정하는거?
                                    -- 1이면 처음부터 찾아라임.
                                    -- 찾되, 2는 L을 찾아낸 위치를 첫번째로 표시할까요 두번째로 표시할까요 라는 얘기.
                                    -- 여기선 첫번째 인덱스부터 L을 찾고, 찾은 위치 두번째를 표시해라~! 라는 얘기 !!!!!
        instr('MILLER', 'x', 1, 2)  -- 찾지 못하면 0을 표시 !ㅜ  
FROM
        dual;

-- ------------------------------------------------------
-- (7) 문자 (처리)함수 : SUBSTR
-- ------------------------------------------------------ 
--      문자열에서, 부분문자열(substring) 반환
-- ------------------------------------------------------
-- 주의) Oracle 의 인덱스 번호는 1부터~~
-- ------------------------------------------------------
SELECT substr('123456-1234567', 8, 1)  -- 위치 인덱스8 1문자를 떼어내라 라는 의미.
FROM dual;  

-- In the Oracle SQL*Developer
SELECT
        hire_date AS 입사일,
        substr(hire_date, 1, 2) AS 입사년도  --> 이거 실행해보면 비쥬얼 소스코드에선 연도가 아닌 일을 갖고옴. 틀림.
                                            --> 같은걸 디벨로퍼에서 실행하면 잘나옴.
   -- In the Visual Source Code
   -- SELECT 
FROM employees;

SELECT
        to_char(hire_date) AS 입사일,           --날짜를 문자열로 바꿔준다. 1) 일,달,연도로 뽑아내서 
        substr( to_char(hire_date), 8, 2) AS 입사년도        --2) 8번째 있는 두자리를 뽑아낸다.       -- 실무에서 to_ 이 문자는 많이쓰임.
FROM
        employees;      

SELECT '900303-1234567', substr('900303-1234567',8)
FROM dual;

--그런데, offset index를 음수로 사용할 수 있다면 ?????
SELECT '900303-1234567', substr('900303-1234567', -8) --> 파이썬에서 사용한 음수 인덱스 그대로.
                                                      --> 전체 길이에 대한 음수. 여기선 7~- 하이픈까지
FROM dual;

-- ------------------------------------------------------
-- (8) 문자 (처리)함수 : REPLACE
-- ------------------------------------------------------ 
--      문자열 치환(replace)
-- ------------------------------------------------------
SELECT replace('JACK and JUE', 'J', 'BL')  -- J : SOURCE, BL : Target
FROM dual;
-- ------------------------------------------------------
-- (9) 문자 (처리)함수 : LPAD
-- ------------------------------------------------------ 
--      문자열 오른쪽 정렬 후, 
--      왼쪽의 빈 공간에 지정문자 채우기(padding)
-- ------------------------------------------------------
SELECT lpad('MILLER', 10, '*') --> L은 무슨방향인지 ?!
FROM dual;
-- ------------------------------------------------------
-- (10) 문자 (처리)함수 : RPAD
-- ------------------------------------------------------ 
--      문자열 왼쪽 정렬 후, 
--      왼쪽의 빈 공간에 지정문자 채우기(padding)
-- ------------------------------------------------------
SELECT rpad('MILLER', 10, '*')
FROM dual;

SELECT substr('900303-1234567', 1, 8) || '*******' AS 주민번호
FROM
        dual
SELECT 
        rpad
                substr('900303-1234567', 1, 8),
                14,
                '*'
        ) AS 주민번호
FROM
        dual; -------> 간단한 코드가 좋긴함.
-- ------------------------------------------------------
-- (11) 문자 (처리)함수 - LTRIM
-- ------------------------------------------------------ 
--      문자열의 왼쪽에서, 지정문자 삭제(trim)
-- ------------------------------------------------------
SELECT ltrim('MMMIMLLER', 'M') --> 삭제할 문자가 M인데, 이건 왼쪽부터 다 삭제함. 다음문자가 삭제문자가 아니면 뒤에 더 있어도 삭제 안됨.
FROM dual;

SELECT 
        ltrim(' MILLER '), --> 삭제할 값을 지정하진 않았지만, 없으면 디폴트값은 공백임. 공백을 삭제 !
        length( ltrim(' MILLER ') )
FROM
        dual;
-- ------------------------------------------------------
-- (12) 문자 (처리)함수 - RTRIM
-- ------------------------------------------------------ 
--      문자열의 왼쪽에서, 지정문자 삭제(trim)
-- ------------------------------------------------------        

SELECT 
        rtrim(' MILLER '), length( rtrim(' MILLER '))
FROM
        dual;
-- ------------------------------------------------------
-- (13) 문자 (처리)함수 - TRIM
-- ------------------------------------------------------ 
--      문자열의 왼쪽/오른쪽/양쪽에서, 지정문자 삭제(trim)
--      (단, 문자열의 중간은 처리 못함)
-- ------------------------------------------------------
-- 문법)
-- TRIM( LEADING 'str' FROM 컬럼명|표현식 ) --> 여기 필기 안함!
-- ------------------------------------------------------
SELECT trim( '0' FROM '0001234567000' )
FROM dual;      -- default: BOTH (양쪽에서 제거)

SELECT trim( LEADING '0' FROM '0001234567000')
FROM dual;      -- 문자열 왼쪽에서 제거/ --> 뒤에 000은 남아있음.

SELECT trim( TRAILING '0' FROM '0001234567000')
FROM dual;      -- 문자열 오른쪽에서 제거/ --> 앞에 000은 남아있음.

